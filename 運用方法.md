# 方針

gem フォルダにある内容を gemini の gem に設定して使うことを想定。

問題点があれば、各 gem の markdown の課題・問題点のセクションにチェックボックスで列挙する。  
gemini/chatGPT などで壁打ちして良い方法があれば、カスタム指示の内容を修正して gem に反映し、コミットする。反映した場合は、該当のチェックボックスを ON にして、対応が終わったことを明確にする。

# 新規作成方法

gem を作る手順として、下記の手順を実施する。

1. ドメインと責務の定義（Scope Definition）

汎用的な Gem を作ろうとすると出力がぼやけます。まずは「何をさせないか」を含めたスコープを決めます。

    役割（Role）の特定: コードレビュアー、インフラ構成案作成者、テストデータ生成器、DB設計アドバイザーなど。

    ターゲット層: ジュニア層の教育用か、シニア層の作業ショートカット用か。

    期待するアウトプット: JSON形式のレスポンス、Mermaid記法の図解、Terraformコードなど。

2. コンテキスト・インジェクション（Contextual Design）

SE として最も重要なステップです。Gem に「自社の流儀」や「技術スタック」を学習させます。

    技術スタックの明示: 「Next.js (App Router), TypeScript, Prisma, PostgreSQL」のようにバージョンを含めて固定します。

    制約事項（Constraints）: * 「命名規則はキャメルケース」

        「エラーハンドリングは必ずtry-catchで囲む」

        「セキュリティの観点からAPIキーは環境変数にする」

    ナレッジの注入: 既存の設計ドキュメントの構成案や、社内のコーディング規約をインストラクションに盛り込みます。

3. プロンプト・エンジニアリング（Implementation）

インストラクション（指示文）を記述します。SE にお馴染みの「構造化」を意識すると精度が上がります。

    Markdownの活用: # Role, # Constraints, # Output Format のように見出しを使い、AIが構造を理解しやすくします。

    Few-shotプロンプティング: 「良い例」と「悪い例」を最低1つずつ提示します。

        例：「関数の説明をコメントに入れる際は、JSDoc形式で記述してください（例：/** ... */）」

4. 境界条件のテストと調整（Testing & QA）

Gem を作成した後、エッジケース（例外系）でテストを行います。

    異常系入力: 曖昧な指示や、あえて制約に反する入力を投げ、適切に拒否または修正案を出せるか確認します。

    ハルシネーション（嘘）の確認: 特にライブラリのメソッド名などが最新のものか、存在しないプロパティを捏造していないか検証します。

    反復改善: 出力が冗長すぎる場合は「簡潔に結論から述べる」といったルールを追加して微調整します。

5. デプロイと共有（Deployment & Iteration）

チームに公開し、フィードバックループを回します。

    READMEの整備: Gemのトップに「何ができるか」「何を入力すべきか」のテンプレートを記載しておきます。

    バージョニング: 技術スタックのアップデート（例：Reactのメジャーアップデート）に合わせて、Gemの指示内容も定期的にメンテナンスします。
